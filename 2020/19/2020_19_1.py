#!/usr/bin/env pypy

import argparse, re, itertools, collections

parser = argparse.ArgumentParser()
parser.add_argument("input",type=str,nargs='?',default="input")
parser.add_argument("--p1",dest="p1",action='store_true')
parser.add_argument("--no-p1",dest="p1",action='store_false')
parser.add_argument("--p2",dest="p2",action='store_true')
parser.add_argument("--no-p2",dest="p2",action='store_false')

args = parser.parse_args()

if not args.p1 and not args.p2:
    args.p1 = True
    args.p2 = True

print("Input: %s P1: %s p2: %s" % (args.input,args.p1,args.p2))

lineRe = re.compile("^([ab]+$)|(?:(\d+): (.*))")
allrules = {}
messages = []

for x in open(args.input).readlines():
    x = x.strip()
    if not x:
        continue

    m = lineRe.match(x)
    if not m:
        print("Invalid line: %s" % (x,))
        
    # Process input line
    if m.group(1):
        messages.append(x)
    else:
        ruleid = int(m.group(2))
        ruleval = []
        for rs in m.group(3).split("|"):
            rs = rs.strip()
            rulepart = []
            if rs[0] == "\"" and rs[2] == "\"":
                rulepart = rs[1]
            else:
                for r in rs.split(" "):
                    r = r.strip()
                    rulepart.append(int(r))
            ruleval.append(rulepart)
        allrules[ruleid] = ruleval

def strmatchlen(message,rule):
    """
    return whether the given 'message' starts with a string that matches the given 
    string `rule`.  `rule` can be '.' which matches any character or other characters
    which must match exactly.
    """
    if len(message) < len(rule):
        return 0
    for i in range(0,len(rule)):
        r = rule[i]
        if r != "." and message[i] != r:
            return 0
    return len(rule)

def matchLen(rules,cache,rid,rule,message):
    """ 
    return the list of lengths that the given `rule` matches at ths start of `message`
    cache results in `cache`, reuse if (message,rid) is already cached.

    rule:  list of rule parts
    rule part: string (matching characters, or '.' matches anything)
               list of strings or other rule ids that must match in order
    """
    if (message,rid) in cache:
        return cache[ (message,rid,) ]
    
    output = []
    for rpart in rule:
        if type(rpart) is str:
            # The entire rule part is a single string match, call `strmatchlen`
            # to see if `message` starts with the specified rule part
            mlen = strmatchlen(message,rpart)
            if mlen:
                output.append(mlen)
        else:
            poses = [0]
            for prid in rpart:
                newposes = []
                if type(prid) is str:
                    # string as part of longer sequence (generated by optimization)
                    # call `strmatchlen` to see if the string startping at each position
                    # in pos is a match for this string.
                    for p in poses:
                        rest = message[p:]
                        mlen = strmatchlen(rest,prid)
                        if mlen:
                            newposes.append(p + mlen)
                elif prid not in rules:
                    # unkonwn rule, nothing matches
                    pass
                else:
                    # a reference to another rule id, recurse to matchLen
                    # with each currently possible match length (poses)
                    rpartrule = rules[prid]
                    for p in poses:
                        if p >= len(message):
                            continue
                        rest = message[p:]
                        ls = matchLen(rules,cache,prid,rpartrule,rest)
                        for l in ls:
                            newposes.append(p + l)
                poses = newposes
            output.extend(poses)

    #print("Message: %s  Rule: %s:%s, matchlens: %s %s" % (message, rid, rule, output, "!" if len(message) in output else ""))
    cache[ (message,rid) ] = output 
    return output

def optimizeRules(rules):
    """
    Transform the given rules:
    - rules that match '"a"|"b"' are replaced by a match of "." 
    - rules that match exactly one string (including .s) are replaced by that string 
      when referred to
    - consecutive string matches are concatenated
    - rules that just match one other rule are replaced by that other rule
    """
    prev = rules
    output = {}

    changed = True
    while changed:
        changed = False
        literals = {}
        for rid,rule in prev.items():
            # any rule that matches exactly one string is a 'literal' that we can
            # consider replacing by that literal in other rules
            if len(rule) == 1 and type(rule[0]) is str:
                literals[rid] = rule[0]

        for rid,rule in prev.items():
            if len(rule) == 1 and type(rule[0]) is int and rule[0] in prev:
                # rules that map to just one other rule can be replaced with that other rule.
                output[rid] = prev[rule[0]]
                changed = True
                continue
            
            newrule = []
            for rpart in rule:
                if type(rpart) is str:
                    # Complete strings remain unchanged
                    newrule.append(rpart)
                else:
                    newpart = []
                    for prid in rpart:
                        if prid in literals:
                            # a literal rule is replaced by the string literal it matches
                            prid = literals[prid]
                            changed = True
                        if type(prid) is str and newpart and type(newpart[-1]) is str:
                            # if the last part of this rule is a string, append to that
                            newpart[-1] = newpart[-1] + prid
                        else:
                            # add this part as the next part of this rule
                            newpart.append(prid)

                    if len(newpart) == 1 and type(newpart[0]) is str:
                        # a rule that is now a single string is replaced by that string
                        newrule.append(newpart[0])
                    else:
                        newrule.append(newpart)
                        
            if len(newrule) == 2 and newrule[0] == "a" and newrule[1] == "b":
                # assume that 'a' and 'b' make up the whole alphabet
                changed = True
                newrule = ["."]
                            
            output[rid] = newrule
        prev = output
                    
    return output
    
def rulesMatch(rules,cache,message):
    for rid,rule in rules.items():
        ls = matchLen(rules,cache,rid,rule,message)
        if not ls:
            continue
        if len(message) in ls:
            return True
    return False

def rulesMatch2(rules,cache,message):
    rid = 0
    rule = rules[0]
    ls = matchLen(rules,cache,rid,rule,message)
    if len(message) in ls:
            return True
    return False

if args.p1:
    print("Doing part 1")

    rules = allrules.copy()
    #print("Rules: %s" % (rules,))
    rules = optimizeRules(rules)
    #print("Optimized Rules: %s" % (rules,))


    matched = 0
    cache = {}
    for message in messages:
        v = rulesMatch2(rules,cache,message)
        #print("m: %s v: %s" % (message,v,))
        if v:
            matched += 1
    print("Matched: %s" % (matched,))
    
if args.p2:
    print("Doing part 2")

    newrules = allrules.copy()
    newrules[ 8 ] = [ [42], [42, 8] ]
    newrules[ 11 ] = [ [42, 31], [ 42, 11, 31] ]

    #print("Rules: %s" % (newrules,))
    newrules = optimizeRules(newrules)
    #print("Optimized Rules: %s" % (newrules,))

    matched = 0
    cache = {}
    for message in messages:
        v = rulesMatch2(newrules,cache,message)
        #print("m: %s v: %s" % (message,v,))
        if v:
            matched += 1
    print("Matched: %s" % (matched,))
